/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import { Outlines, useGLTF } from "@react-three/drei";
import { useThree, useFrame } from "@react-three/fiber";
import { GLTF } from "three-stdlib";
import { useMemo, useRef, useState } from "react";
import { RigidBody, RapierRigidBody } from "@react-three/rapier";
import { useGameStore } from "../../../context/game-store";

type GLTFResult = GLTF & {
  nodes: {
    Ball: THREE.Mesh;
  };
  materials: {};
};

export function Ball() {
  const { nodes } = useGLTF(
    "/models/in-game/Ball/Ball.glb",
  ) as unknown as GLTFResult;

  const rigidBodyRef = useRef<RapierRigidBody>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState<THREE.Vector3 | null>(null);
  const [dragCurrent, setDragCurrent] = useState<THREE.Vector3 | null>(null);
  const { camera } = useThree();

  const handlePointerDown = (e: any) => {
    // Prevent camera controls from taking over
    e.stopPropagation();

    // In React Three Fiber, event.point is the 3D interaction point
    // using the event's ray intersection
    if (rigidBodyRef.current) {
      // Stop the ball momentarily to aim? Optional, but helpful.
      rigidBodyRef.current.setLinvel({ x: 0, y: 0, z: 0 }, true);
      rigidBodyRef.current.setAngvel({ x: 0, y: 0, z: 0 }, true);
    }

    setIsDragging(true);
    setDragStart(e.point.clone());
    setDragCurrent(e.point.clone());

    // Capture pointer to track outside mesh
    (e.target as HTMLElement).setPointerCapture(e.pointerId);
  };

  const handlePointerMove = (e: any) => {
    if (!isDragging || !dragStart) return;

    // We need to raycast to a "virtual floor" plane at the ball's height
    // to get consistent dragging even if we move off the ball mesh
    const floorPlane = new THREE.Plane(
      new THREE.Vector3(0, 1, 0),
      -dragStart.y,
    );
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(e.pointer, camera);
    const intersectPoint = new THREE.Vector3();

    // Check intersection with our horizontal plane
    if (raycaster.ray.intersectPlane(floorPlane, intersectPoint)) {
      setDragCurrent(intersectPoint);
    }
  };

  const handlePointerUp = (e: any) => {
    if (!isDragging || !dragStart || !dragCurrent || !rigidBodyRef.current)
      return;

    setIsDragging(false);
    (e.target as HTMLElement).releasePointerCapture(e.pointerId);

    // Calculate Vector: Start -> Current = Drag Vector
    // Slingshot: Pull BACK (Current) to shoot FORWARD (Opposite of Pull)
    // Shot Vector = Start - Current
    const shotVector = new THREE.Vector3().subVectors(dragStart, dragCurrent);

    // Multiplier for power
    const forceMultiplier = 10.0; // Adjust as needed
    const impulse = shotVector.multiplyScalar(forceMultiplier);

    // Flatten Y to prevent shooting into ground or too high up initially,
    // though a little Y might be nice for a "chip". Let's keep it mostly flat for now.
    impulse.y = Math.abs(impulse.y) * 0.1;

    rigidBodyRef.current.applyImpulse(impulse, true);

    setDragStart(null);
    setDragCurrent(null);
  };

  // Calculate arrow direction and length
  const arrowData = useMemo(() => {
    if (!isDragging || !dragStart || !dragCurrent) return null;

    // Direction from dragCurrent (pull position) to dragStart (ball position)
    // This shows where the ball will go
    const direction = new THREE.Vector3().subVectors(dragStart, dragCurrent);
    let length = direction.length();

    // Minimum length to show arrow
    if (length < 0.1) return null;
    if (length > 10) length = 10;

    direction.normalize();

    // Calculate rotation to point in the direction
    const quaternion = new THREE.Quaternion().setFromUnitVectors(
      new THREE.Vector3(0, 1, 0), // Arrow points up by default
      direction,
    );

    return {
      position: dragStart,
      direction,
      length,
      quaternion,
    };
  }, [isDragging, dragStart, dragCurrent]);

  return (
    <group dispose={null}>
      <RigidBody
        position={[0, 112, 0]}
        scale={0.5}
        ref={rigidBodyRef}
        colliders="ball"
        restitution={0.8}
        friction={1.0}
        linearDamping={0.5}
        angularDamping={0.5}
        name="ball"
        type="dynamic"
      >
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Ball.geometry}
          material={nodes.Ball.material}
          onPointerDown={handlePointerDown}
          onPointerMove={handlePointerMove}
          onPointerUp={handlePointerUp}
          // No position prop needed - mesh follows RigidBody automatically
        >
          <Outlines thickness={0.5} color="black" angle={0} />
        </mesh>
      </RigidBody>

      {/* Arrow indicator showing shot direction and strength */}
      {arrowData && (
        <group
          position={[
            arrowData.position.x + 0.1,
            arrowData.position.y,
            arrowData.position.z,
          ]}
          quaternion={arrowData.quaternion}
        >
          {/* Arrow shaft */}
          <mesh position={[0, arrowData.length / 2, 0]}>
            <cylinderGeometry args={[0.3, 0.3, arrowData.length, 8]} />
            <meshBasicMaterial color="#00ff00" transparent opacity={0.8} />
          </mesh>

          {/* Arrow head */}
          <mesh position={[0, arrowData.length, 0]}>
            <coneGeometry args={[1, 2, 8]} />
            <meshBasicMaterial color="#00ff00" transparent opacity={0.8} />
          </mesh>
        </group>
      )}
    </group>
  );
}

useGLTF.preload("/models/in-game/Ball/Ball.glb");
